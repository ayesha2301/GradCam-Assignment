# -*- coding: utf-8 -*-
"""Assignment 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jPamn3uiEkIOH2XAgiODMScf45hEK7-1
"""

# Downloading the saved resnet18 model weights
!wget https://github.com/qubvel/classification_models/releases/download/0.0.1/resnet18_imagenet_1000.h5
!ls

!pip install git+https://github.com/qubvel/classification_models.git

import keras
from keras.datasets import cifar10
from keras.utils import np_utils
import numpy as np
from keras.models import load_model
from classification_models.resnet import ResNet18, preprocess_input
import skimage.transform
import keras.backend as K
import cv2
from keras.preprocessing.image import ImageDataGenerator
from keras.callbacks import ReduceLROnPlateau, CSVLogger, EarlyStopping
import sys
from keras.preprocessing import image
import matplotlib.pyplot as plt
from classification_models import Classifiers
from keras.layers import (GlobalAveragePooling2D, Activation, Convolution2D)
from keras.layers.convolutional import Conv2D
import pandas as pd

nb_classes = 10
batch_size = 32

(X_train, y_train), (X_test, y_test) = cifar10.load_data()

# Convert class vectors to binary class matrices.

Y_train = np_utils.to_categorical(y_train, nb_classes)

Y_test = np_utils.to_categorical(y_test, nb_classes)



X_train = X_train.astype('float32')

X_test = X_test.astype('float32')

# subtract mean and normalize

mean_image = np.mean(X_train, axis=0)

X_train -= mean_image

X_test -= mean_image

X_train /= 128.

X_test /= 128.

lr_reducer = ReduceLROnPlateau(factor=np.sqrt(0.1), cooldown=0, patience=5, min_lr=0.5e-6)

early_stopper = EarlyStopping(min_delta=0.001, patience=10)

csv_logger = CSVLogger('resnet18_cifar10.csv')

base_model = ResNet18((32, 32, 3), weights='imagenet', include_top=True, classes=1000)

base_model.load_weights('resnet18_imagenet_1000.h5')
#base_model.layers.pop()

#for layer in base_model.layers:
#    layer.trainable = False


conv2 = Conv2D(10, 1, activation='relu')(base_model.layers[-4].output)
gap = GlobalAveragePooling2D()(conv2)
activation = Activation('softmax')(gap)

model = keras.models.Model(inputs=[base_model.input], outputs=[activation])
print(model.summary())

# train
model.compile(optimizer='SGD', loss='categorical_crossentropy', metrics=['accuracy'])

"""
datagen = ImageDataGenerator(featurewise_center=False,  # set input mean to 0 over the dataset
                                 samplewise_center=False,  # set each sample mean to 0
                                 featurewise_std_normalization=False,  # divide inputs by std of the dataset
                                 samplewise_std_normalization=False,  # divide each input by its std
                                 zca_whitening=False,  # apply ZCA whitening
                                 rotation_range=0,  # randomly rotate images in the range (degrees, 0 to 180)
                                 width_shift_range=0.1,  # randomly shift images horizontally (fraction of total width)
                                 height_shift_range=0.1,  # randomly shift images vertically (fraction of total height)
                                 horizontal_flip=True,  # randomly flip images
                                 vertical_flip=False)  # randomly flip images

datagen.fit(X_train)

model.fit_generator(datagen.flow(X_train, Y_train, batch_size=batch_size),
                        steps_per_epoch=X_train.shape[0] // batch_size,
                        validation_data=(X_test, Y_test),
                        epochs=50, verbose=1, max_q_size=100,
                        callbacks=[lr_reducer, early_stopper, csv_logger])
"""
    
    
model.fit(X_train, Y_train, batch_size=batch_size, nb_epoch=10, 
              validation_data=(X_test, Y_test), shuffle=True, 
              callbacks=[lr_reducer, early_stopper, csv_logger])

# Gradcam

# preds = model.predict(X_test)

preds = model.predict(X_test)
result = np.absolute(Y_test-preds)
result_summed = [np.mean(arr) for arr in result]

result_df = pd.DataFrame(result_summed, columns=['pred_diff'])
result_df = result_df.sort_values(by='pred_diff', ascending=True)
sorted_errors = result_df.index
misclassified = sorted_errors[:50]

#correct_indices = np.nonzero(predicted_classes == y_test)[0] 
#incorrect_indices = np.nonzero(predicted_classes != y_test)[0] 
#print(len(correct_indices)," classified correctly") 
#print(len(incorrect_indices)," classified incorrectly")

class_idx = np.argmax(preds[0])
class_output = model.output[:, class_idx]
last_conv_layer = model.get_layer("stage4_unit2_conv2")

grads = K.gradients(class_output, last_conv_layer.output)[0]
pooled_grads = K.mean(grads, axis=(0, 1, 2))
iterate = K.function([model.input], [pooled_grads, last_conv_layer.output[0]])
pooled_grads_value, conv_layer_output_value = iterate([X_test])
for i in range(512):
    conv_layer_output_value[:, :, i] *= pooled_grads_value[i]

heatmap = np.mean(conv_layer_output_value, axis=-1)
heatmap = np.maximum(heatmap, 0)
heatmap /= np.max(heatmap)

def resize_image(img, heatmap):
  heatmap = cv2.resize(heatmap, (32, 32))
  #cm_hot = mpl.cm.get_cmap('jet')
  #heatmap = cm_hot(heatmap)
  heatmap = np.uint8(255.0 * heatmap)
  heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
  #heatmap = cv2.cvtColor(heatmap, cv2.COLOR_BGR2RGB)
  heatmap = np.asarray(heatmap, np.float32)

  superimposed_img = cv2.addWeighted(img, 0.7, heatmap, 0.9, 0)
  
  return superimposed_img

for i in misclassified:
  img = X_test[i+1]    
  
  fig, (ax1, ax2) = plt.subplots(ncols=2, sharex=True, figsize=(5, 5))
  
  superimposed_img = resize_image(img, heatmap)
  print(superimposed_img.shape)  
  
  # ax1 = plt.subplot(211)
  ax1.imshow(img)
  ax1.set_title("Original Image")
  ax2.imshow(superimposed_img)
  ax2.set_title("GradCam Image")
  plt.show()
  plt.clf()

#print('Train: X=%s, y=%s' % (X_train.shape, Y_train.shape))
#print('Test: X=%s, y=%s' % (X_test.shape, Y_test.shape))
# plot first few images
#for i in misclassified:
	# define subplot
#	pyplot.subplot(330 + 1 + i)
	# plot raw pixel data
#	plt.imshow(X_train[i])
# show the figure
#pyplot.show()